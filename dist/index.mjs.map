{"version":3,"sources":["../src/constants.ts","../node_modules/ethers/src.ts/_version.ts","../node_modules/ethers/src.ts/utils/properties.ts","../node_modules/ethers/src.ts/utils/errors.ts","../node_modules/ethers/src.ts/utils/data.ts","../node_modules/ethers/src.ts/utils/maths.ts","../node_modules/ethers/src.ts/utils/fixednumber.ts","../node_modules/ethers/src.ts/utils/units.ts","../src/fixtures.ts","../src/types.ts","../src/services.ts"],"sourcesContent":["import { constants } from 'starknet';\n\nexport const STAGING_BASE_URL = 'https://goerli.api.avnu.fi';\nexport const BASE_URL = 'https://starknet.api.avnu.fi';\nexport const AVNU_ADDRESS: { [chainId: string]: string } = {\n  [constants.StarknetChainId.SN_MAIN]: '0x4270219d365d6b017231b52e92b3fb5d7c8378b05e9abc97724537a80e93b0f',\n  [`${constants.StarknetChainId.SN_MAIN}-dev`]: '0x33c21d4cd5db846109448b3e827d175e50b6d449387f76ca7f91a881edca44b',\n  [constants.StarknetChainId.SN_GOERLI]: '0x7e36202ace0ab52bf438bd8a8b64b3731c48d09f0d8879f5b006384c2f35032',\n  [`${constants.StarknetChainId.SN_GOERLI}-dev`]: '0x6d8cd321dcbbf54512eab67c8a6849faf920077a3996f40bb4761adc4f021d2',\n};\n","/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n\n/**\n *  The current version of Ethers.\n */\nexport const version: string = \"6.8.1\";\n","/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\n\nfunction checkType(value: any, type: string, name: string): void {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof(value) === type) { return; }\n        }\n    }\n\n    const error: any = new Error(`invalid value for type ${ type }`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${ name }`;\n    error.value = value;\n\n    throw error;\n}\n\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties<T>(value: { [ P in keyof T ]: T[P] | Promise<T[P]>}): Promise<T> {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[<keyof T>k])));\n    return results.reduce((accum: any, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, <{ [ P in keyof T]: T[P] }>{ });\n}\n\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties<T>(\n target: T,\n values: { [ K in keyof T ]?: T[K] },\n types?: { [ K in keyof T ]?: string }): void {\n\n    for (let key in values) {\n        let value = values[key];\n\n        const type = (types ? types[key]: null);\n        if (type) { checkType(value, type, key); }\n\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n","/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\n\nimport { version } from \"../_version.js\";\n\nimport { defineProperties } from \"./properties.js\";\n\nimport type {\n    TransactionRequest, TransactionReceipt, TransactionResponse\n} from \"../providers/index.js\";\n\nimport type { FetchRequest, FetchResponse } from \"./fetch.js\";\n\n/**\n *  An error may contain additional properties, but those must not\n *  conflict with any impliciat properties.\n */\nexport type ErrorInfo<T> = Omit<T, \"code\" | \"name\" | \"message\" | \"shortMessage\"> & { shortMessage?: string };\n\n\nfunction stringify(value: any): any {\n    if (value == null) { return \"null\"; }\n\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n\n    if (typeof(value) === \"object\" && typeof(value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n\n    switch (typeof(value)) {\n        case \"boolean\": case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${ stringify(k) }: ${ stringify(value[k]) }`).join(\", \") + \" }\";\n        }\n    }\n\n    return `[ COULD NOT SERIALIZE ]`;\n}\n\n/**\n *  All errors emitted by ethers have an **ErrorCode** to help\n *  identify and coalesce errors to simplfy programatic analysis.\n *\n *  Each **ErrorCode** is the %%code%% proerty of a coresponding\n *  [[EthersError]].\n *\n *  **Generic Errors**\n *\n *  **``\"UNKNOWN_ERROR\"``** - see [[UnknownError]]\n *\n *  **``\"NOT_IMPLEMENTED\"``** - see [[NotImplementedError]]\n *\n *  **``\"UNSUPPORTED_OPERATION\"``** - see [[UnsupportedOperationError]]\n *\n *  **``\"NETWORK_ERROR\"``** - see [[NetworkError]]\n *\n *  **``\"SERVER_ERROR\"``** - see [[ServerError]]\n *\n *  **``\"TIMEOUT\"``** - see [[TimeoutError]]\n *\n *  **``\"BAD_DATA\"``** - see [[BadDataError]]\n *\n *  **``\"CANCELLED\"``** - see [[CancelledError]]\n *\n *  **Operational Errors**\n *\n *  **``\"BUFFER_OVERRUN\"``** - see [[BufferOverrunError]]\n *\n *  **``\"NUMERIC_FAULT\"``** - see [[NumericFaultError]]\n *\n *  **Argument Errors**\n *\n *  **``\"INVALID_ARGUMENT\"``** - see [[InvalidArgumentError]]\n *\n *  **``\"MISSING_ARGUMENT\"``** - see [[MissingArgumentError]]\n *\n *  **``\"UNEXPECTED_ARGUMENT\"``** - see [[UnexpectedArgumentError]]\n *\n *  **``\"VALUE_MISMATCH\"``** - //unused//\n *\n *  **Blockchain Errors**\n *\n *  **``\"CALL_EXCEPTION\"``** - see [[CallExceptionError]]\n *\n *  **``\"INSUFFICIENT_FUNDS\"``** - see [[InsufficientFundsError]]\n *\n *  **``\"NONCE_EXPIRED\"``** - see [[NonceExpiredError]]\n *\n *  **``\"REPLACEMENT_UNDERPRICED\"``** - see [[ReplacementUnderpricedError]]\n *\n *  **``\"TRANSACTION_REPLACED\"``** - see [[TransactionReplacedError]]\n *\n *  **``\"UNCONFIGURED_NAME\"``** - see [[UnconfiguredNameError]]\n *\n *  **``\"OFFCHAIN_FAULT\"``** - see [[OffchainFaultError]]\n *\n *  **User Interaction Errors**\n *\n *  **``\"ACTION_REJECTED\"``** - see [[ActionRejectedError]]\n */\nexport type ErrorCode =\n\n    // Generic Errors\n    \"UNKNOWN_ERROR\" | \"NOT_IMPLEMENTED\" | \"UNSUPPORTED_OPERATION\" |\n    \"NETWORK_ERROR\" | \"SERVER_ERROR\" | \"TIMEOUT\" | \"BAD_DATA\" |\n    \"CANCELLED\" |\n\n    // Operational Errors\n    \"BUFFER_OVERRUN\" |  \"NUMERIC_FAULT\" |\n\n    // Argument Errors\n    \"INVALID_ARGUMENT\" | \"MISSING_ARGUMENT\" | \"UNEXPECTED_ARGUMENT\" |\n    \"VALUE_MISMATCH\" |\n\n    // Blockchain Errors\n    \"CALL_EXCEPTION\" | \"INSUFFICIENT_FUNDS\" | \"NONCE_EXPIRED\" |\n    \"REPLACEMENT_UNDERPRICED\" | \"TRANSACTION_REPLACED\" |\n    \"UNCONFIGURED_NAME\" | \"OFFCHAIN_FAULT\" |\n\n    // User Interaction\n    \"ACTION_REJECTED\"\n;\n\n/**\n *  All errors in Ethers include properties to assist in\n *  machine-readable errors.\n */\nexport interface EthersError<T extends ErrorCode = ErrorCode> extends Error {\n    /**\n     *  The string error code.\n     */\n    code: ErrorCode;\n\n    /**\n     *  A short message describing the error, with minimal additional\n     *  details.\n     */\n    shortMessage: string;\n\n    /**\n     *  Additional info regarding the error that may be useful.\n     *\n     *  This is generally helpful mostly for human-based debugging.\n     */\n    info?: Record<string, any>;\n\n    /**\n     *  Any related error.\n     */\n    error?: Error;\n}\n\n// Generic Errors\n\n/**\n *  This Error is a catch-all for when there is no way for Ethers to\n *  know what the underlying problem is.\n */\nexport interface UnknownError extends EthersError<\"UNKNOWN_ERROR\"> {\n    [ key: string ]: any;\n}\n\n/**\n *  This Error is mostly used as a stub for functionality that is\n *  intended for the future, but is currently not implemented.\n */\nexport interface NotImplementedError extends EthersError<\"NOT_IMPLEMENTED\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}\n\n/**\n *  This Error indicates that the attempted operation is not supported.\n *\n *  This could range from a specifc JSON-RPC end-point not supporting\n *  a feature to a specific configuration of an object prohibiting the\n *  operation.\n *\n *  For example, a [[Wallet]] with no connected [[Provider]] is unable\n *  to send a transaction.\n */\nexport interface UnsupportedOperationError extends EthersError<\"UNSUPPORTED_OPERATION\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}\n\n/**\n *  This Error indicates a proplem connecting to a network.\n */\nexport interface NetworkError extends EthersError<\"NETWORK_ERROR\"> {\n    /**\n     *  The network event.\n     */\n    event: string;\n}\n\n/**\n *  This Error indicates there was a problem fetching a resource from\n *  a server.\n */\nexport interface ServerError extends EthersError<\"SERVER_ERROR\"> {\n    /**\n     *  The requested resource.\n     */\n    request: FetchRequest | string;\n\n    /**\n     *  The response received from the server, if available.\n     */\n    response?: FetchResponse;\n}\n\n/**\n *  This Error indicates that the timeout duration has expired and\n *  that the operation has been implicitly cancelled.\n *\n *  The side-effect of the operation may still occur, as this\n *  generally means a request has been sent and there has simply\n *  been no response to indicate whether it was processed or not.\n */\nexport interface TimeoutError extends EthersError<\"TIMEOUT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The reason.\n     */\n    reason: string;\n\n    /**\n     *  The resource request, if available.\n     */\n    request?: FetchRequest;\n}\n\n/**\n *  This Error indicates that a provided set of data cannot\n *  be correctly interpretted.\n */\nexport interface BadDataError extends EthersError<\"BAD_DATA\"> {\n    /**\n     *  The data.\n     */\n    value: any;\n}\n\n/**\n *  This Error indicates that the operation was cancelled by a\n *  programmatic call, for example to ``cancel()``.\n */\nexport interface CancelledError extends EthersError<\"CANCELLED\"> {\n}\n\n\n// Operational Errors\n\n/**\n *  This Error indicates an attempt was made to read outside the bounds\n *  of protected data.\n *\n *  Most operations in Ethers are protected by bounds checks, to mitigate\n *  exploits when parsing data.\n */\nexport interface BufferOverrunError extends EthersError<\"BUFFER_OVERRUN\"> {\n    /**\n     *  The buffer that was overrun.\n     */\n    buffer: Uint8Array;\n\n    /**\n     *  The length of the buffer.\n     */\n    length: number;\n\n    /**\n     *  The offset that was requested.\n     */\n    offset: number;\n}\n\n/**\n *  This Error indicates an operation which would result in incorrect\n *  arithmetic output has occurred.\n *\n *  For example, trying to divide by zero or using a ``uint8`` to store\n *  a negative value.\n */\nexport interface NumericFaultError extends EthersError<\"NUMERIC_FAULT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The fault reported.\n     */\n    fault: string;\n\n    /**\n     *  The value the operation was attempted against.\n     */\n    value: any;\n}\n\n\n// Argument Errors\n\n/**\n *  This Error indicates an incorrect type or value was passed to\n *  a function or method.\n */\nexport interface InvalidArgumentError extends EthersError<\"INVALID_ARGUMENT\"> {\n    /**\n     *  The name of the argument.\n     */\n    argument: string;\n\n    /**\n     *  The value that was provided.\n     */\n    value: any;\n\n    info?: Record<string, any>\n}\n\n/**\n *  This Error indicates there were too few arguments were provided.\n */\nexport interface MissingArgumentError extends EthersError<\"MISSING_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}\n\n/**\n *  This Error indicates too many arguments were provided.\n */\nexport interface UnexpectedArgumentError extends EthersError<\"UNEXPECTED_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}\n\n\n// Blockchain Errors\n\n/**\n *  The action that resulted in the call exception.\n */\nexport type CallExceptionAction = \"call\" | \"estimateGas\" | \"getTransactionResult\" | \"sendTransaction\" | \"unknown\";\n\n/**\n *  The related transaction that caused the error.\n */\nexport type CallExceptionTransaction = {\n    to: null | string;\n    from?: string;\n    data: string;\n};\n\n/**\n *  This **Error** indicates a transaction reverted.\n */\nexport interface CallExceptionError extends EthersError<\"CALL_EXCEPTION\"> {\n\n    /**\n     *  The action being performed when the revert was encountered.\n     */\n    action: CallExceptionAction;\n\n    /**\n     *  The revert data returned.\n     */\n    data: null | string;\n\n    /**\n     *  A human-readable representation of data, if possible.\n     */\n    reason: null | string;\n\n    /**\n     *  The transaction that triggered the exception.\n     */\n    transaction: CallExceptionTransaction,\n\n    /**\n     *  The contract invocation details, if available.\n     */\n    invocation: null | {\n        method: string;\n        signature: string;\n        args: Array<any>;\n    }\n\n    /**\n     *  The built-in or custom revert error, if available\n     */\n    revert: null | {\n        signature: string;\n        name: string;\n        args: Array<any>;\n    }\n\n    /**\n     *  If the error occurred in a transaction that was mined\n     *  (with a status of ``0``), this is the receipt.\n     */\n    receipt?: TransactionReceipt;   // @TODO: in v7, make this `null | TransactionReceipt`\n}\n\n\n/**\n *  The sending account has insufficient funds to cover the\n *  entire transaction cost.\n */\nexport interface InsufficientFundsError extends EthersError<\"INSUFFICIENT_FUNDS\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  The sending account has already used this nonce in a\n *  transaction that has been included.\n */\nexport interface NonceExpiredError extends EthersError<\"NONCE_EXPIRED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  A CCIP-read exception, which cannot be recovered from or\n *  be further processed.\n */\nexport interface OffchainFaultError extends EthersError<\"OFFCHAIN_FAULT\"> {\n    /**\n     *  The transaction.\n     */\n    transaction?: TransactionRequest;\n\n    /**\n     *  The reason the CCIP-read failed.\n     */\n    reason: string;\n}\n\n/**\n *  An attempt was made to replace a transaction, but with an\n *  insufficient additional fee to afford evicting the old\n *  transaction from the memory pool.\n */\nexport interface ReplacementUnderpricedError extends EthersError<\"REPLACEMENT_UNDERPRICED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  A pending transaction was replaced by another.\n */\nexport interface TransactionReplacedError extends EthersError<\"TRANSACTION_REPLACED\"> {\n    /**\n     *  If the transaction was cancelled, such that the original\n     *  effects of the transaction cannot be assured.\n     */\n    cancelled: boolean;\n\n    /**\n     *  The reason the transaction was replaced.\n     */\n    reason: \"repriced\" | \"cancelled\" | \"replaced\";\n\n    /**\n     *  The hash of the replaced transaction.\n     */\n    hash: string;\n\n    /**\n     *  The transaction that replaced the transaction.\n     */\n    replacement: TransactionResponse;\n\n    /**\n     *  The receipt of the transaction that replace the transaction.\n     */\n    receipt: TransactionReceipt;\n}\n\n/**\n *  This Error indicates an ENS name was used, but the name has not\n *  been configured.\n *\n *  This could indicate an ENS name is unowned or that the current\n *  address being pointed to is the [[ZeroAddress]].\n */\nexport interface UnconfiguredNameError extends EthersError<\"UNCONFIGURED_NAME\"> {\n    /**\n     *  The ENS name that was requested\n     */\n    value: string;\n}\n\n/**\n *  This Error indicates a request was rejected by the user.\n *\n *  In most clients (such as MetaMask), when an operation requires user\n *  authorization (such as ``signer.sendTransaction``), the client\n *  presents a dialog box to the user. If the user denies the request\n *  this error is thrown.\n */\nexport interface ActionRejectedError extends EthersError<\"ACTION_REJECTED\"> {\n    /**\n     *  The requested action.\n     */\n    action: \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\" | \"unknown\",\n\n    /**\n     *  The reason the action was rejected.\n     *\n     *  If there is already a pending request, some clients may indicate\n     *  there is already a ``\"pending\"`` action. This prevents an app\n     *  from spamming the user.\n     */\n    reason: \"expired\" | \"rejected\" | \"pending\"\n}\n\n// Coding; converts an ErrorCode its Typed Error\n\n/**\n *  A conditional type that transforms the [[ErrorCode]] T into\n *  its EthersError type.\n *\n *  @flatworm-skip-docs\n */\nexport type CodedEthersError<T> =\n    T extends \"UNKNOWN_ERROR\" ? UnknownError:\n    T extends \"NOT_IMPLEMENTED\" ? NotImplementedError:\n    T extends \"UNSUPPORTED_OPERATION\" ? UnsupportedOperationError:\n    T extends \"NETWORK_ERROR\" ? NetworkError:\n    T extends \"SERVER_ERROR\" ? ServerError:\n    T extends \"TIMEOUT\" ? TimeoutError:\n    T extends \"BAD_DATA\" ? BadDataError:\n    T extends \"CANCELLED\" ? CancelledError:\n\n    T extends \"BUFFER_OVERRUN\" ? BufferOverrunError:\n    T extends \"NUMERIC_FAULT\" ? NumericFaultError:\n\n    T extends \"INVALID_ARGUMENT\" ? InvalidArgumentError:\n    T extends \"MISSING_ARGUMENT\" ? MissingArgumentError:\n    T extends \"UNEXPECTED_ARGUMENT\" ? UnexpectedArgumentError:\n\n    T extends \"CALL_EXCEPTION\" ? CallExceptionError:\n    T extends \"INSUFFICIENT_FUNDS\" ? InsufficientFundsError:\n    T extends \"NONCE_EXPIRED\" ? NonceExpiredError:\n    T extends \"OFFCHAIN_FAULT\" ? OffchainFaultError:\n    T extends \"REPLACEMENT_UNDERPRICED\" ? ReplacementUnderpricedError:\n    T extends \"TRANSACTION_REPLACED\" ? TransactionReplacedError:\n    T extends \"UNCONFIGURED_NAME\" ? UnconfiguredNameError:\n\n    T extends \"ACTION_REJECTED\" ? ActionRejectedError:\n\n    never;\n\n\n\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript envornoments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nexport function isError<K extends ErrorCode, T extends CodedEthersError<K>>(error: any, code: K): error is T {\n    return (error && (<EthersError>error).code === code);\n}\n\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nexport function isCallException(error: any): error is CallExceptionError {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additioanl properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depneding on %%code%%, additional\n *  required properties. The error message will also include the %%meeage%%,\n *  ethers version, %%code%% and all aditional properties, serialized.\n */\nexport function makeError<K extends ErrorCode, T extends CodedEthersError<K>>(message: string, code: K, info?: ErrorInfo<T>): T {\n    let shortMessage = message;\n\n    {\n        const details: Array<string> = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${ stringify(info) }`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") { continue; }\n                const value = <any>(info[<keyof ErrorInfo<T>>key]);\n//                try {\n                    details.push(key + \"=\" + stringify(value));\n//                } catch (error: any) {\n//                console.log(\"MMM\", error.message);\n//                    details.push(key + \"=[could not serialize object]\");\n//                }\n            }\n        }\n        details.push(`code=${ code }`);\n        details.push(`version=${ version }`);\n\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n\n    defineProperties<EthersError>(<EthersError>error, { code });\n\n    if (info) { Object.assign(error, info); }\n\n    if ((<any>error).shortMessage == null) {\n        defineProperties<EthersError>(<EthersError>error, { shortMessage });\n    }\n\n    return <T>error;\n}\n\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nexport function assert<K extends ErrorCode, T extends CodedEthersError<K>>(check: unknown, message: string, code: K, info?: ErrorInfo<T>): asserts check {\n    if (!check) { throw makeError(message, code, info); }\n}\n\n\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nexport function assertArgument(check: unknown, message: string, name: string, value: unknown): asserts check {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\n\nexport function assertArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message == null) { message = \"\"; }\n    if (message) { message = \": \" + message; }\n\n    assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n\n    assert(count <= expectedCount, \"too many arguemnts\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\n\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") { throw new Error(\"bad\"); };\n        /* c8 ignore stop */\n\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301)\n            /* c8 ignore start */\n            if (check !== expected) { throw new Error(\"broken\") }\n            /* c8 ignore stop */\n        }\n\n        accum.push(form);\n    } catch(error) { }\n\n    return accum;\n}, <Array<string>>[]);\n\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nexport function assertNormalize(form: string): void {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nexport function assertPrivate(givenGuard: any, guard: any, className?: string): void {\n    if (className == null) { className = \"\"; }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${ method }from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n","/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\n\n/**\n *  A [[HexString]] whose length is even, which ensures it is a valid\n *  representation of binary data.\n */\nexport type DataHexString = string;\n\n/**\n *  A string which is prefixed with ``0x`` and followed by any number\n *  of case-agnostic hexadecimal characters.\n *\n *  It must match the regular expression ``/0x[0-9A-Fa-f]*\\/``.\n */\nexport type HexString = string;\n\n/**\n *  An object that can be used to represent binary data.\n */\nexport type BytesLike = DataHexString | Uint8Array;\n\nfunction _getBytes(value: BytesLike, name?: string, copy?: boolean): Uint8Array {\n    if (value instanceof Uint8Array) {\n        if (copy) { return new Uint8Array(value); }\n        return value;\n    }\n\n    if (typeof(value) === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, false);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, true);\n}\n\n\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value: any, length?: number | boolean): value is `0x${ string }` {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n\n    if (typeof(length) === \"number\" && value.length !== 2 + 2 * length) { return false; }\n    if (length === true && (value.length % 2) !== 0) { return false; }\n\n    return true;\n}\n\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value: any): value is BytesLike {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data: BytesLike): string {\n    const bytes = getBytes(data);\n\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas: ReadonlyArray<BytesLike>): string {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data: BytesLike): number {\n    if (isHexString(data, true)) { return (data.length - 2) / 2; }\n    return getBytes(data).length;\n}\n\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data: BytesLike, start?: number, end?: number): string {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0: start, (end == null) ? bytes.length: end));\n}\n\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data: BytesLike): string {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) { bytes = bytes.substring(2); }\n    return \"0x\" + bytes;\n}\n\nfunction zeroPad(data: BytesLike, length: number, left: boolean): string {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n\n    return hexlify(result);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data: BytesLike, length: number): string {\n    return zeroPad(data, length, true);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data: BytesLike, length: number): string {\n    return zeroPad(data, length, false);\n}\n","/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\n\nimport type { BytesLike } from \"./data.js\";\n\n/**\n *  Any type that can be used where a numeric value is needed.\n */\nexport type Numeric = number | bigint;\n\n/**\n *  Any type that can be used where a big number is needed.\n */\nexport type BigNumberish = string | Numeric;\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n\n\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nexport function fromTwos(_value: BigNumberish, _width: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n\n    return value;\n}\n\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nexport function toTwos(_value: BigNumberish, _width: Numeric): bigint {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    const limit = (BN_1 << (width - BN_1));\n\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    } else {\n        assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n\n    return value;\n}\n\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nexport function mask(_value: BigNumberish, _bits: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getBigInt(value: BigNumberish, name?: string): bigint {\n    switch (typeof(value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch(e: any) {\n                assertArgument(false, `invalid BigNumberish string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nexport function getUint(value: BigNumberish, name?: string): bigint {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\n\nconst Nibbles = \"0123456789abcdef\";\n\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nexport function toBigInt(value: BigNumberish | Uint8Array): bigint {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n\n    return getBigInt(value);\n}\n\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getNumber(value: BigNumberish, name?: string): number {\n    switch (typeof(value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                return getNumber(BigInt(value), name);\n            } catch(e: any) {\n                assertArgument(false, `invalid numeric string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n\n\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nexport function toNumber(value: BigNumberish | Uint8Array): number {\n    return getNumber(toBigInt(value));\n}\n\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nexport function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n    const value = getUint(_value, \"value\");\n\n    let result = value.toString(16);\n\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) { result = \"0\" + result; }\n    } else {\n        const width = getNumber(_width, \"width\");\n        assert(width * 2 >= result.length, `value exceeds width (${ width } bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n\n        // Pad the value to the required width\n        while (result.length < (width * 2)) { result = \"0\" + result; }\n\n    }\n\n    return \"0x\" + result;\n}\n\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nexport function toBeArray(_value: BigNumberish): Uint8Array {\n    const value = getUint(_value, \"value\");\n\n    if (value === BN_0) { return new Uint8Array([ ]); }\n\n    let hex = value.toString(16);\n    if (hex.length % 2) { hex = \"0\" + hex; }\n\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n\n    return result;\n}\n\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nexport function toQuantity(value: BytesLike | BigNumberish): string {\n    let result = hexlify(isBytesLike(value) ? value: toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) { result = result.substring(1); }\n    if (result === \"\") { result = \"0\"; }\n    return \"0x\" + result;\n}\n","/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\nimport { getBytes } from \"./data.js\";\nimport { assert, assertArgument, assertPrivate } from \"./errors.js\";\nimport {\n    getBigInt, getNumber, fromTwos, mask, toBigInt\n} from \"./maths.js\";\nimport { defineProperties } from \"./properties.js\";\n\nimport type { BigNumberish, BytesLike, Numeric } from \"./index.js\";\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\n\nconst _guard = { };\n\n\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) { Zeros += Zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals: number): bigint {\n    let result = Zeros;\n    while (result.length < decimals) { result += result; }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\n\n\n\n    /*\n     *  Returns a new FixedFormat for %%value%%.\n     *\n     *  If %%value%% is specified as a ``number``, the bit-width is\n     *  128 bits and %%value%% is used for the ``decimals``.\n     *\n     *  A string %%value%% may begin with ``fixed`` or ``ufixed``\n     *  for signed and unsigned respectfully. If no other properties\n     *  are specified, the bit-width is 128-bits with 18 decimals.\n     *\n     *  To specify the bit-width and demicals, append them separated\n     *  by an ``\"x\"`` to the %%value%%.\n     *\n     *  For example, ``ufixed128x18`` describes an unsigned, 128-bit\n     *  wide format with 18 decimals.\n     *\n     *  If %%value%% is an other object, its properties for ``signed``,\n     *  ``width`` and ``decimals`` are checked.\n     */\n\n/**\n *  A description of a fixed-point arithmetic field.\n *\n *  When specifying the fixed format, the values override the default of\n *  a ``fixed128x18``, which implies a signed 128-bit value with 18\n *  decimals of precision.\n *\n *  The alias ``fixed`` and ``ufixed`` can be used for ``fixed128x18`` and\n *  ``ufixed128x18`` respectively.\n *\n *  When a fixed format string begins with a ``u``, it indicates the field\n *  is unsigned, so any negative values will overflow. The first number\n *  indicates the bit-width and the second number indicates the decimal\n *  precision.\n *\n *  When a ``number`` is used for a fixed format, it indicates the number\n *  of decimal places, and the default width and signed-ness will be used.\n *\n *  The bit-width must be byte aligned and the decimals can be at most 80.\n */\nexport type FixedFormat = number | string | {\n    signed?: boolean,\n    width?: number,\n    decimals?: number\n};\n\nfunction checkValue(val: bigint, format: _FixedFormat, safeOp?: string): bigint {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: <string>safeOp, fault: \"overflow\", value: val\n        });\n\n        if (val > BN_0) {\n            val = fromTwos(mask(val, width), width);\n        } else {\n            val = -fromTwos(mask(-val, width), width);\n        }\n\n    } else {\n        const limit = (BN_1 << width);\n        assert(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: <string>safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n\n    return val;\n}\n\ntype _FixedFormat = { signed: boolean, width: number, decimals: number, name: string }\n\nfunction getFormat(value?: FixedFormat): _FixedFormat {\n    if (typeof(value) === \"number\") { value = `fixed128x${value}` }\n\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n\n    if (typeof(value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        } else if (value === \"ufixed\") {\n            signed = false;\n        } else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            assertArgument(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    } else if (value) {\n        // Extract the values from the object\n        const v: any = value;\n        const check = (key: string, type: string, defaultValue: any): any => {\n            if (v[key] == null) { return defaultValue; }\n            assertArgument(typeof(v[key]) === type,\n                \"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, v[key]);\n            return v[key];\n        }\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n\n    assertArgument((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    assertArgument(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n\n    const name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n    return { signed, width, decimals, name };\n}\n\nfunction toString(val: bigint, decimals: number) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n\n    let str = val.toString();\n\n    // No decimal point for whole values\n    if (decimals === 0) { return (negative + str); }\n\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) { str = Zeros + str; }\n\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n\n    return (negative + str);\n}\n\n\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, an value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nexport class FixedNumber {\n\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    readonly format!: string;\n\n    readonly #format: _FixedFormat;\n\n    // The actual value (accounting for decimals)\n    #val: bigint;\n\n    // A base-10 value to multiple values by to maintain the magnitude\n    readonly #tens: bigint;\n\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    readonly _value!: string;\n\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, value: bigint, format: any) {\n        assertPrivate(guard, _guard, \"FixedNumber\");\n\n        this.#val = value;\n\n        this.#format = format;\n\n        const _value = toString(value, format.decimals);\n\n        defineProperties<FixedNumber>(this, { format: format.name, _value });\n\n        this.#tens = getTens(format.decimals);\n    }\n\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed(): boolean { return this.#format.signed; }\n\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width(): number { return this.#format.width; }\n\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals(): number { return this.#format.decimals; }\n\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value(): bigint { return this.#val; }\n\n    #checkFormat(other: FixedNumber): void {\n        assertArgument(this.format === other.format,\n            \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n\n    #checkValue(val: bigint, safeOp?: string): FixedNumber {\n/*\n        const width = BigInt(this.width);\n        if (this.signed) {\n            const limit = (BN_1 << (width - BN_1));\n            assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                operation: <string>safeOp, fault: \"overflow\", value: val\n            });\n\n            if (val > BN_0) {\n                val = fromTwos(mask(val, width), width);\n            } else {\n                val = -fromTwos(mask(-val, width), width);\n            }\n\n        } else {\n            const masked = mask(val, width);\n            assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                operation: <string>safeOp, fault: \"overflow\", value: val\n            });\n            val = masked;\n        }\n*/\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n\n    #add(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other: FixedNumber): FixedNumber { return this.#add(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other: FixedNumber): FixedNumber { return this.#add(other, \"add\"); }\n\n    #sub(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other: FixedNumber): FixedNumber { return this.#sub(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other: FixedNumber): FixedNumber { return this.#sub(other, \"sub\"); }\n\n    #mul(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other: FixedNumber): FixedNumber { return this.#mul(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other: FixedNumber): FixedNumber { return this.#mul(other, \"mul\"); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other: FixedNumber): FixedNumber {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        assert((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n\n    #div(o: FixedNumber, safeOp?: string): FixedNumber {\n        assert(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other: FixedNumber): FixedNumber { return this.#div(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other: FixedNumber): FixedNumber { return this.#div(other, \"div\"); }\n\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other: FixedNumber): FixedNumber {\n        assert(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        assert((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n     cmp(other: FixedNumber): number {\n         let a = this.value, b = other.value;\n\n         // Coerce a and b to the same magnitude\n         const delta = this.decimals - other.decimals;\n         if (delta > 0) {\n             b *= getTens(delta);\n         } else if (delta < 0) {\n             a *= getTens(-delta);\n         }\n\n         // Comnpare\n         if (a < b) { return -1; }\n         if (a > b) { return 1; }\n         return 0;\n     }\n\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n     eq(other: FixedNumber): boolean { return this.cmp(other) === 0; }\n\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n     lt(other: FixedNumber): boolean { return this.cmp(other) < 0; }\n\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n     lte(other: FixedNumber): boolean { return this.cmp(other) <= 0; }\n\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n     gt(other: FixedNumber): boolean { return this.cmp(other) > 0; }\n\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n     gte(other: FixedNumber): boolean { return this.cmp(other) >= 0; }\n\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor(): FixedNumber {\n        let val = this.#val;\n        if (this.#val < BN_0) { val -= this.#tens - BN_1; }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling(): FixedNumber {\n        let val = this.#val;\n        if (this.#val > BN_0) { val += this.#tens - BN_1; }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) { return this; }\n\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n\n        checkValue(value, this.#format, \"round\");\n\n        return new FixedNumber(_guard, value, this.#format);\n    }\n\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero(): boolean { return (this.#val === BN_0); }\n\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative(): boolean { return (this.#val < BN_0); }\n\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString(): string { return this._value; }\n\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format: FixedFormat): FixedNumber {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value: BigNumberish, _decimals?: Numeric, _format?: FixedFormat): FixedNumber {\n        const decimals = (_decimals == null) ? 0: getNumber(_decimals);\n        const format = getFormat(_format);\n\n        let value = getBigInt(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            assert((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        } else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n\n        checkValue(value, format, \"fromValue\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value: string, _format?: FixedFormat): FixedNumber {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        assertArgument(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n\n        const format = getFormat(_format);\n\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n\n        // Pad out the decimals\n        while (decimal.length < format.decimals) { decimal += Zeros; }\n\n        // Check precision is safe\n        assert(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n\n        const value = BigInt(match[1] + whole + decimal)\n\n        checkValue(value, format, \"fromString\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value: BytesLike, _format?: FixedFormat): FixedNumber {\n        let value = toBigInt(getBytes(_value, \"value\"));\n        const format = getFormat(_format);\n\n        if (format.signed) { value = fromTwos(value, format.width); }\n\n        checkValue(value, format, \"fromBytes\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n}\n\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n","/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */\nimport { assertArgument } from \"./errors.js\";\nimport { FixedNumber } from \"./fixednumber.js\";\nimport { getNumber } from \"./maths.js\";\n\nimport type { BigNumberish, Numeric } from \"../utils/index.js\";\n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */\nexport function formatUnits(value: BigNumberish, unit?: string | Numeric): string {\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = getNumber(unit, \"unit\");\n    }\n\n    return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\n}\n\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */\nexport function parseUnits(value: string, unit?: string | Numeric): bigint {\n    assertArgument(typeof(value) === \"string\", \"value must be a string\", \"value\", value);\n\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = getNumber(unit, \"unit\");\n    }\n\n    return FixedNumber.fromString(value, { decimals, width: 512 }).value;\n}\n\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */\nexport function formatEther(wei: BigNumberish): string {\n    return formatUnits(wei, 18);\n}\n\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */\nexport function parseEther(ether: string): bigint {\n    return parseUnits(ether, 18);\n}\n","import { parseUnits } from 'ethers';\nimport { constants } from 'starknet';\nimport {\n  BuildSwapTransaction,\n  InvokeSwapResponse,\n  Page,\n  Pair,\n  Price,\n  PriceRequest,\n  Quote,\n  QuoteRequest,\n  Source,\n  SourceType,\n  Token,\n} from './types';\n\nexport const aPriceRequest = (): PriceRequest => ({\n  sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n  sellAmount: parseUnits('1', 18),\n  buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n});\n\nexport const aQuoteRequest = (): QuoteRequest => ({\n  sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n  sellAmount: parseUnits('1', 18),\n  buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n  size: 1,\n  takerAddress: '0x0',\n});\n\nexport const aPrice = (): Price => ({\n  sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n  sellAmount: parseUnits('1', 18),\n  sellAmountInUsd: 1700,\n  buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n  buyAmount: parseUnits('2', 18),\n  buyAmountInUsd: 1700,\n  blockNumber: 1,\n  chainId: constants.StarknetChainId.SN_GOERLI,\n  sourceName: 'AMM1',\n  priceRatioUsd: 0,\n  gasFees: BigInt(0),\n  gasFeesInUsd: 0,\n});\n\nexport const aQuote = (): Quote => ({\n  quoteId: 'quoteId',\n  sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n  sellAmount: parseUnits('1', 18),\n  sellAmountInUsd: 1700,\n  buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n  buyAmount: parseUnits('2', 18),\n  buyAmountInUsd: 1700,\n  buyAmountWithoutFees: parseUnits('2', 18),\n  buyAmountWithoutFeesInUsd: 1700,\n  blockNumber: 1,\n  chainId: constants.StarknetChainId.SN_GOERLI,\n  expiry: 100000000000,\n  routes: [\n    {\n      name: 'AMM1',\n      address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c661',\n      percent: 1,\n      sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n      buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n      routes: [],\n    },\n  ],\n  gasFees: BigInt('0x0'),\n  gasFeesInUsd: 0,\n  avnuFees: BigInt('0x0'),\n  avnuFeesInUsd: 0,\n  avnuFeesBps: BigInt('0x0'),\n  integratorFees: BigInt('0x0'),\n  integratorFeesInUsd: 0,\n  integratorFeesBps: BigInt('0x0'),\n  priceRatioUsd: 0,\n  liquiditySource: 'DEX_AGGREGATOR',\n  suggestedSolution: undefined,\n});\n\nexport const aQuoteWithManySubRoutes = (): Quote => ({\n  quoteId: 'quoteId',\n  sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n  sellAmount: parseUnits('1', 18),\n  sellAmountInUsd: 1700,\n  buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n  buyAmount: parseUnits('2', 18),\n  buyAmountInUsd: 1700,\n  buyAmountWithoutFees: parseUnits('2', 18),\n  buyAmountWithoutFeesInUsd: 1700,\n  blockNumber: 1,\n  chainId: constants.StarknetChainId.SN_GOERLI,\n  expiry: 100000000000,\n  priceRatioUsd: 0,\n  liquiditySource: 'DEX_AGGREGATOR',\n  routes: [\n    {\n      name: 'AMM1',\n      address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c661',\n      percent: 1,\n      sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n      buyTokenAddress: '0x3e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9',\n      routes: [\n        {\n          name: 'AMM2',\n          address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c662',\n          percent: 1,\n          sellTokenAddress: '0x3e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9',\n          buyTokenAddress: '0x2e2faab2cad8ecdde5e991798673ddcc08983b872304a66e5f99fbb24e14abc',\n          routes: [\n            {\n              name: 'AMM1',\n              address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c661',\n              percent: 1,\n              sellTokenAddress: '0x2e2faab2cad8ecdde5e991798673ddcc08983b872304a66e5f99fbb24e14abc',\n              buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n              routes: [],\n            },\n          ],\n        },\n      ],\n    },\n  ],\n  gasFees: BigInt('0x0'),\n  gasFeesInUsd: 0,\n  avnuFees: BigInt('0x0'),\n  avnuFeesInUsd: 0,\n  avnuFeesBps: BigInt('0x0'),\n  integratorFees: BigInt('0x0'),\n  integratorFeesInUsd: 0,\n  integratorFeesBps: BigInt('0x0'),\n  suggestedSolution: undefined,\n});\n\nexport const aQuoteWithManyComplexRoutes = (): Quote => ({\n  quoteId: 'quoteId',\n  sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n  sellAmount: parseUnits('1', 18),\n  sellAmountInUsd: 1700,\n  buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n  buyAmount: parseUnits('2', 18),\n  buyAmountInUsd: 1700,\n  buyAmountWithoutFees: parseUnits('2', 18),\n  buyAmountWithoutFeesInUsd: 1700,\n  blockNumber: 1,\n  chainId: constants.StarknetChainId.SN_GOERLI,\n  expiry: 100000000000,\n  gasFees: BigInt('0x0'),\n  gasFeesInUsd: 0,\n  avnuFees: BigInt('0x0'),\n  avnuFeesInUsd: 0,\n  avnuFeesBps: BigInt('0x0'),\n  integratorFees: BigInt('0x0'),\n  integratorFeesInUsd: 0,\n  integratorFeesBps: BigInt('0x0'),\n  priceRatioUsd: 0,\n  liquiditySource: 'DEX_AGGREGATOR',\n  routes: [\n    {\n      name: 'AMM1',\n      address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c661',\n      percent: 0.5,\n      sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n      buyTokenAddress: '0x3e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9',\n      routes: [\n        {\n          name: 'AMM2',\n          address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c662',\n          percent: 0.5,\n          sellTokenAddress: '0x3e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9',\n          buyTokenAddress: '0x2e2faab2cad8ecdde5e991798673ddcc08983b872304a66e5f99fbb24e14abc',\n          routes: [\n            {\n              name: 'AMM1',\n              address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c661',\n              percent: 1,\n              sellTokenAddress: '0x2e2faab2cad8ecdde5e991798673ddcc08983b872304a66e5f99fbb24e14abc',\n              buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n              routes: [],\n            },\n          ],\n        },\n        {\n          name: 'AMM1',\n          address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c661',\n          percent: 0.5,\n          sellTokenAddress: '0x3e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9',\n          buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n          routes: [],\n        },\n      ],\n    },\n    {\n      name: 'AMM1',\n      address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c661',\n      percent: 0.2,\n      sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n      buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n      routes: [],\n    },\n    {\n      name: 'AMM1',\n      address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c661',\n      percent: 0.3,\n      sellTokenAddress: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n      buyTokenAddress: '0x3e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9',\n      routes: [\n        {\n          name: 'AMM2',\n          address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c662',\n          percent: 0.2,\n          sellTokenAddress: '0x3e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9',\n          buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n          routes: [],\n        },\n        {\n          name: 'AMM1',\n          address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c661',\n          percent: 0.8,\n          sellTokenAddress: '0x3e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9',\n          buyTokenAddress: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n          routes: [],\n        },\n      ],\n    },\n  ],\n  suggestedSolution: undefined,\n});\n\nexport const anInvokeSwapResponse = (): InvokeSwapResponse => ({\n  transactionHash: '0x0',\n});\n\nexport const aBuildSwapTransaction = (): BuildSwapTransaction => ({\n  chainId: constants.StarknetChainId.SN_GOERLI,\n  contractAddress: '0x0',\n  entrypoint: 'execute',\n  calldata: [],\n});\n\nexport const ethToken = (): Token => ({\n  name: 'Ethereum',\n  address: '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',\n  symbol: 'ETH',\n  decimals: 18,\n  chainId: '0x534e5f474f45524c49',\n  logoUri:\n    'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png',\n});\n\nexport const btcToken = (): Token => ({\n  name: 'Wrapped Bitcoin',\n  address: '0x72df4dc5b6c4df72e4288857317caf2ce9da166ab8719ab8306516a2fddfff7',\n  symbol: 'WBTC',\n  decimals: 18,\n  chainId: '0x534e5f474f45524c49',\n  logoUri:\n    'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599/logo.png',\n});\n\nexport const aPair = (): Pair => ({\n  token1: ethToken(),\n  token2: btcToken(),\n});\n\nexport const aPage = <T>(content: T[], size = 10, number = 0, totalPages = 1, totalElements = 1): Page<T> => ({\n  content,\n  size,\n  totalPages,\n  number,\n  totalElements,\n});\n\nexport const aSource = (): Source => ({\n  name: 'AMM1',\n  address: '0x975910cd99bc56bd289eaaa5cee6cd557f0ddafdb2ce6ebea15b158eb2c661',\n  icon: 'https://pbs.twimg.com/profile_images/1567441002063069184/SGtDtW-C_400x400.jpg',\n  type: SourceType.DEX,\n});\n","import { Call, Signature } from 'starknet';\n\nexport interface Pageable {\n  page?: number;\n  size?: number;\n  sort?: string;\n}\n\nexport type GetTokensRequest = Pageable;\n\nexport interface GetPairsRequest extends Pageable {\n  token?: string;\n}\n\nexport interface Page<T> {\n  content: T[];\n  totalPages: number;\n  totalElements: number;\n  size: number;\n  number: number;\n}\n\nexport interface Token {\n  name: string;\n  address: string;\n  symbol: string;\n  decimals: number;\n  chainId: string;\n  logoUri: string;\n}\n\nexport interface Pair {\n  token1: Token;\n  token2: Token;\n}\n\nexport interface PriceRequest {\n  sellTokenAddress: string;\n  buyTokenAddress: string;\n  sellAmount: bigint;\n}\n\nexport interface QuoteRequest {\n  sellTokenAddress: string;\n  buyTokenAddress: string;\n  sellAmount: bigint;\n  takerAddress?: string;\n  size?: number;\n  excludeSources?: string[];\n  integratorFees?: bigint;\n  integratorFeeRecipient?: string;\n  integratorName?: string;\n  mode?: 'CLASSIC' | 'TURBO';\n}\n\nexport interface Route {\n  name: string;\n  address: string;\n  percent: number;\n  sellTokenAddress: string;\n  buyTokenAddress: string;\n  routeInfo?: Map<string, string>;\n  routes: Route[];\n}\n\nexport interface Price {\n  sellTokenAddress: string;\n  sellAmount: bigint;\n  sellAmountInUsd: number;\n  buyTokenAddress: string;\n  buyAmount: bigint;\n  buyAmountInUsd: number;\n  blockNumber?: number;\n  chainId: string;\n  sourceName: string;\n  priceRatioUsd: number;\n  gasFees: bigint;\n  gasFeesInUsd: number;\n}\n\nexport interface Quote {\n  quoteId: string;\n  sellTokenAddress: string;\n  sellAmount: bigint;\n  sellAmountInUsd: number;\n  buyTokenAddress: string;\n  buyAmount: bigint;\n  buyAmountInUsd: number;\n  buyAmountWithoutFees: bigint;\n  buyAmountWithoutFeesInUsd: number;\n  blockNumber?: number;\n  chainId: string;\n  expiry?: number;\n  routes: Route[];\n  gasFees: bigint;\n  gasFeesInUsd: number;\n  avnuFees: bigint;\n  avnuFeesInUsd: number;\n  avnuFeesBps: bigint;\n  integratorFees: bigint;\n  integratorFeesInUsd: number;\n  integratorFeesBps: bigint;\n  priceRatioUsd: number;\n  sellTokenPriceInUsd?: number;\n  buyTokenPriceInUsd?: number;\n  liquiditySource: 'DEX_AGGREGATOR' | 'MARKET_MAKER' | 'SOLVER';\n  suggestedSolution?: SuggestedSolution;\n}\n\nexport interface SuggestedSolution {\n  sellAmount: bigint;\n  sellAmountInUsd?: number;\n  buyAmount: bigint;\n  buyAmountInUsd?: number;\n}\n\nexport interface InvokeSwapResponse {\n  transactionHash: string;\n}\n\nexport interface RequestError {\n  messages: string[];\n}\n\nexport interface AvnuOptions {\n  baseUrl?: string;\n  dev?: boolean;\n  abortSignal?: AbortSignal;\n  avnuPublicKey?: string;\n}\n\nexport interface ExecuteSwapOptions {\n  executeApprove?: boolean;\n  gasless?: boolean;\n  takerSignature?: Signature;\n  slippage?: number;\n}\n\nexport interface BuildSwapTransaction extends Call {\n  chainId: string;\n}\n\nexport enum SourceType {\n  DEX = 'DEX',\n  MARKET_MAKER = 'MARKET_MAKER',\n  SOLVER = 'SOLVER',\n}\n\nexport interface Source {\n  name: string;\n  address: string;\n  icon?: string;\n  type: SourceType;\n}\n","import { toBeHex } from 'ethers';\nimport qs from 'qs';\nimport { AccountInterface, Call, ec, hash, Signature, typedData, uint256 } from 'starknet';\nimport { AVNU_ADDRESS, BASE_URL, STAGING_BASE_URL } from './constants';\nimport {\n  AvnuOptions,\n  BuildSwapTransaction,\n  ExecuteSwapOptions,\n  GetTokensRequest,\n  InvokeSwapResponse,\n  Page,\n  Price,\n  PriceRequest,\n  Quote,\n  QuoteRequest,\n  RequestError,\n  Source,\n  Token,\n} from './types';\n\nconst getBaseUrl = (): string => (process.env.NODE_ENV === 'dev' ? STAGING_BASE_URL : BASE_URL);\n\nconst parseResponse = <T>(response: Response, avnuPublicKey?: string): Promise<T> => {\n  if (response.status === 400) {\n    return response.json().then((error: RequestError) => {\n      throw new Error(error.messages[0]);\n    });\n  }\n  if (response.status > 400) {\n    throw new Error(`${response.status} ${response.statusText}`);\n  }\n  if (avnuPublicKey) {\n    const signature = response.headers.get('signature');\n    if (!signature) throw new Error('No server signature');\n    return response\n      .clone()\n      .text()\n      .then((textResponse) => {\n        const hashResponse = hash.computeHashOnElements([hash.starknetKeccak(textResponse)]);\n        const formattedSig = signature.split(',').map((s) => BigInt(s));\n        const signatureType = new ec.starkCurve.Signature(formattedSig[0], formattedSig[1]);\n        if (!ec.starkCurve.verify(signatureType, hashResponse, avnuPublicKey))\n          throw new Error('Invalid server signature');\n      })\n      .then(() => response.json());\n  }\n  return response.json();\n};\n\n/**\n * Fetches the prices of DEX applications.\n * It allows to find the prices of AMM without any path optimization. It allows to measure the performance of the results from the getQuotes endpoints. The prices are sorted (best first).\n *\n * @param request: The request params for the avnu API `/swap/v1/prices` endpoint.\n * @param options: Optional options.\n * @returns The best quotes\n */\nconst fetchPrices = (request: PriceRequest, options?: AvnuOptions): Promise<Price[]> => {\n  const queryParams = qs.stringify({ ...request, sellAmount: toBeHex(request.sellAmount) }, { arrayFormat: 'repeat' });\n  return fetch(`${options?.baseUrl ?? getBaseUrl()}/swap/v1/prices?${queryParams}`, {\n    signal: options?.abortSignal,\n    headers: { ...(options?.avnuPublicKey !== undefined && { 'ask-signature': 'true' }) },\n  })\n    .then((response) => parseResponse<Price[]>(response, options?.avnuPublicKey))\n    .then((prices) =>\n      prices.map((price) => ({\n        ...price,\n        sellAmount: BigInt(price.sellAmount),\n        buyAmount: BigInt(price.buyAmount),\n        gasFees: BigInt(price.gasFees),\n      })),\n    );\n};\n\n/**\n * Fetches the best quotes.\n * It allows to find the best quotes from on-chain and off-chain liquidity. The best quotes will be returned and are sorted (best first).\n *\n * @param request: The request params for the avnu API `/swap/v1/quotes` endpoint.\n * @param options: Optional options.\n * @returns The best quotes\n */\nconst fetchQuotes = (request: QuoteRequest, options?: AvnuOptions): Promise<Quote[]> => {\n  const queryParams = qs.stringify(\n    {\n      ...request,\n      sellAmount: toBeHex(request.sellAmount),\n      integratorFees: request.integratorFees ? toBeHex(request.integratorFees) : undefined,\n    },\n    { arrayFormat: 'repeat' },\n  );\n  return fetch(`${options?.baseUrl ?? getBaseUrl()}/swap/v1/quotes?${queryParams}`, {\n    signal: options?.abortSignal,\n    headers: { ...(options?.avnuPublicKey !== undefined && { 'ask-signature': 'true' }) },\n  })\n    .then((response) => parseResponse<Quote[]>(response, options?.avnuPublicKey))\n    .then((quotes) =>\n      quotes.map((quote) => ({\n        ...quote,\n        sellAmount: BigInt(quote.sellAmount),\n        buyAmount: BigInt(quote.buyAmount),\n        buyAmountWithoutFees: BigInt(quote.buyAmountWithoutFees),\n        gasFees: BigInt(quote.gasFees),\n        avnuFees: BigInt(quote.avnuFees),\n        integratorFees: BigInt(quote.integratorFees),\n        avnuFeesBps: BigInt(quote.avnuFeesBps),\n        integratorFeesBps: BigInt(quote.integratorFeesBps),\n        suggestedSolution: quote.suggestedSolution\n          ? {\n              ...quote.suggestedSolution,\n              sellAmount: BigInt(quote.suggestedSolution.sellAmount),\n              buyAmount: BigInt(quote.suggestedSolution.buyAmount),\n            }\n          : undefined,\n      })),\n    );\n};\n\n/**\n * Executing the exchange through AVNU router\n *\n * @param quoteId: The id of the selected quote\n * @param takerSignature: Taker's signature.\n * @param nonce: Taker's address nonce. See `buildGetNonce`\n * @param takerAddress: Required when taker address was not provided during the quote request\n * @param slippage: The maximum acceptable slippage of the buyAmount amount. Default value is 5%. 0.05 is 5%.\n * This value is ignored if slippage is not applicable to the selected quote\n * @param options: Optional options.\n * @returns The transaction hash\n */\nconst fetchExecuteSwapTransaction = (\n  quoteId: string,\n  takerSignature: Signature,\n  nonce: string,\n  takerAddress?: string,\n  slippage?: number,\n  options?: AvnuOptions,\n): Promise<InvokeSwapResponse> => {\n  let signature: string[] = [];\n\n  if (Array.isArray(takerSignature)) {\n    signature = takerSignature.map((sig) => toBeHex(BigInt(sig)));\n  } else if (takerSignature.r && takerSignature.s) {\n    signature = [toBeHex(BigInt(takerSignature.r)), toBeHex(BigInt(takerSignature.s))];\n  }\n  return fetch(`${options?.baseUrl ?? getBaseUrl()}/swap/v1/execute`, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      ...(options?.avnuPublicKey && { 'ask-signature': 'true' }),\n    },\n    body: JSON.stringify({\n      quoteId,\n      takerAddress,\n      nonce,\n      slippage,\n      takerSignature: signature,\n    }),\n  }).then((response) => parseResponse<InvokeSwapResponse>(response, options?.avnuPublicKey));\n};\n\n/**\n * Build data for executing the exchange through AVNU router\n * It allows trader to build the data needed for executing the exchange on AVNU router\n *\n * @param quoteId: The id of the selected quote\n * @param nonce: Taker's address nonce. See `buildGetNonce`. Warning: the nonce mechanism will change\n * @param takerAddress: Required when taker address was not provided during the quote request\n * @param slippage: The maximum acceptable slippage of the buyAmount amount. Default value is 5%. 0.05 is 5%.\n * This value is ignored if slippage is not applicable to the selected quote\n * @param options: Optional options.\n * @returns The calldata\n */\nconst fetchBuildExecuteTransaction = (\n  quoteId: string,\n  nonce?: string,\n  takerAddress?: string,\n  slippage?: number,\n  options?: AvnuOptions,\n): Promise<BuildSwapTransaction> =>\n  fetch(`${options?.baseUrl ?? getBaseUrl()}/swap/v1/build`, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      ...(options?.avnuPublicKey && { 'ask-signature': 'true' }),\n    },\n    body: JSON.stringify({ quoteId, takerAddress, nonce, slippage }),\n  }).then((response) => parseResponse<BuildSwapTransaction>(response, options?.avnuPublicKey));\n\n/**\n * Fetches the supported tokens.\n *\n * @param request: The request params for the avnu API `/swap/v1/tokens` endpoint.\n * @param options: Optional options.\n * @returns The best quotes\n */\nconst fetchTokens = (request?: GetTokensRequest, options?: AvnuOptions): Promise<Page<Token>> =>\n  fetch(`${options?.baseUrl ?? getBaseUrl()}/swap/v1/tokens?${qs.stringify(request ?? {})}`, {\n    signal: options?.abortSignal,\n    headers: { ...(options?.avnuPublicKey && { 'ask-signature': 'true' }) },\n  }).then((response) => parseResponse<Page<Token>>(response, options?.avnuPublicKey));\n\n/**\n * Fetches the supported sources\n *\n * @param options: Optional options.\n * @returns The sources\n */\nconst fetchSources = (options?: AvnuOptions): Promise<Source[]> =>\n  fetch(`${options?.baseUrl ?? getBaseUrl()}/swap/v1/sources`, {\n    signal: options?.abortSignal,\n    headers: { ...(options?.avnuPublicKey && { 'ask-signature': 'true' }) },\n  }).then((response) => parseResponse<Source[]>(response, options?.avnuPublicKey));\n\n/**\n * Verifies if the address is whitelisted\n * Throws an error when the contractAddress is not whitelisted\n *\n * @param contractAddress: The address to check\n * @param chainId: The chainId\n */\nconst checkContractAddress = (contractAddress: string, chainId: string, dev?: boolean) => {\n  if (!(dev ? AVNU_ADDRESS[`${chainId}-dev`] : AVNU_ADDRESS[chainId])?.includes(contractAddress)) {\n    throw Error(`Contract ${contractAddress} is not whitelisted`);\n  }\n};\n\n/**\n * Build approve call\n *\n * @param sellTokenAddress: The sell token address\n * @param sellAmount: The sell amount\n * @param chainId: The chainId\n * @param dev: Specify if you need to use the dev environment  * @returns Call\n */\nconst buildApproveTx = (sellTokenAddress: string, sellAmount: bigint, chainId: string, dev?: boolean): Call => {\n  const value = uint256.bnToUint256(toBeHex(sellAmount));\n  return {\n    contractAddress: sellTokenAddress,\n    entrypoint: 'approve',\n    calldata: [dev ? AVNU_ADDRESS[`${chainId}-dev`] : AVNU_ADDRESS[chainId], value.low, value.high],\n  };\n};\n\n/**\n * Build getNonce call\n *\n * @param takerAddress: The taker's address\n * @param chainId: The chainId\n * @param dev: Specify if you need to use the dev environment\n * @returns Call\n */\nconst buildGetNonce = (takerAddress: string, chainId: string, dev?: boolean): Call => ({\n  contractAddress: dev ? AVNU_ADDRESS[`${chainId}-dev`] : AVNU_ADDRESS[chainId],\n  entrypoint: 'getNonce',\n  calldata: [BigInt(takerAddress).toString()],\n});\n\n/**\n * Sign the quote\n * The signature will be used in the AVNU contract\n *\n * @param account: The account of the trader\n * @param quote: The selected quote. See `getQuotes`\n * @param nonce: Taker's address nonce. See `buildGetNonce`\n * @param chainId: The chainId\n * @returns Call\n */\nconst signQuote = (account: AccountInterface, quote: Quote, nonce: string, chainId: string): Promise<Signature> =>\n  account.signMessage({\n    domain: { name: 'AVNUFinance', version: '1', chainId: chainId },\n    message: {\n      taker_address: account.address,\n      taker_token_address: quote.sellTokenAddress,\n      taker_token_amount: toBeHex(quote.sellAmount),\n      maker_address: quote.routes[0].address,\n      maker_token_address: quote.buyTokenAddress,\n      maker_token_amount: toBeHex(quote.buyAmount),\n      nonce,\n    },\n    primaryType: 'TakerMessage',\n    types: {\n      StarkNetDomain: [\n        { name: 'name', type: 'felt' },\n        { name: 'version', type: 'felt' },\n        { name: 'chainId', type: 'felt' },\n      ],\n      TakerMessage: [\n        { name: 'taker_address', type: 'felt' },\n        { name: 'taker_token_address', type: 'felt' },\n        { name: 'taker_token_amount', type: 'felt' },\n        { name: 'maker_address', type: 'felt' },\n        { name: 'maker_token_address', type: 'felt' },\n        { name: 'maker_token_amount', type: 'felt' },\n        { name: 'nonce', type: 'felt' },\n      ],\n    },\n  });\n\nconst hashQuote = (accountAddress: string, quote: Quote, nonce: string, chainId: string): string =>\n  typedData.getMessageHash(\n    {\n      domain: { name: 'AVNUFinance', version: '1', chainId: chainId },\n      message: {\n        taker_address: accountAddress,\n        taker_token_address: quote.sellTokenAddress,\n        taker_token_amount: toBeHex(quote.sellAmount),\n        maker_address: quote.routes[0].address,\n        maker_token_address: quote.buyTokenAddress,\n        maker_token_amount: toBeHex(quote.buyAmount),\n        nonce,\n      },\n      primaryType: 'TakerMessage',\n      types: {\n        StarkNetDomain: [\n          { name: 'name', type: 'felt' },\n          { name: 'version', type: 'felt' },\n          { name: 'chainId', type: 'felt' },\n        ],\n        TakerMessage: [\n          { name: 'taker_address', type: 'felt' },\n          { name: 'taker_token_address', type: 'felt' },\n          { name: 'taker_token_amount', type: 'felt' },\n          { name: 'maker_address', type: 'felt' },\n          { name: 'maker_token_address', type: 'felt' },\n          { name: 'maker_token_amount', type: 'felt' },\n          { name: 'nonce', type: 'felt' },\n        ],\n      },\n    },\n    accountAddress,\n  );\n\n/**\n * Execute the exchange\n *\n * @param account: The account of the trader\n * @param quote: The selected quote. See `getQuotes`\n * @param nonce: Taker's address nonce. See `buildGetNonce`\n * @param executeApprove: False if the taker already executed `approve`\n * @param gasless: False if the user wants to execute the transaction himself\n * @param takerSignature: Optional: the function will ask the user tu sign the quote if param is undefined\n * @param slippage: The maximum acceptable slippage of the buyAmount amount. Default value is 5%. 0.05 is 5%.\n * This value is ignored if slippage is not applicable to the selected quote\n * @param options: Optional options.\n * @returns Promise<InvokeSwapResponse>\n */\nconst executeSwap = async (\n  account: AccountInterface,\n  quote: Quote,\n  { executeApprove = true, gasless = false, takerSignature, slippage }: ExecuteSwapOptions = {},\n  options?: AvnuOptions,\n): Promise<InvokeSwapResponse> => {\n  const chainId = await account.getChainId();\n  if (chainId !== quote.chainId) {\n    throw Error(`Invalid chainId`);\n  }\n\n  const approve = executeApprove\n    ? buildApproveTx(quote.sellTokenAddress, quote.sellAmount, quote.chainId, options?.dev)\n    : undefined;\n\n  // /!\\ Do not implement this yourself. It will change /!\\\n  let nonce = undefined;\n  if (quote.liquiditySource === 'MARKET_MAKER' || gasless) {\n    const getNonce = buildGetNonce(account.address, chainId, options?.dev);\n    const response = await account.callContract(getNonce);\n    nonce = response.result[0];\n  }\n\n  if (gasless) {\n    if (approve) await account.execute([approve]);\n    takerSignature = takerSignature ?? (await signQuote(account, quote, nonce!, quote.chainId));\n    return fetchExecuteSwapTransaction(quote.quoteId, takerSignature, nonce!, account.address, slippage, options);\n  } else {\n    return fetchBuildExecuteTransaction(quote.quoteId, nonce, account.address, slippage, options)\n      .then((call) => {\n        checkContractAddress(call.contractAddress, call.chainId, options?.dev);\n        return account.execute(approve ? [approve, call] : [call]);\n      })\n      .then((value) => ({ transactionHash: value.transaction_hash }));\n  }\n};\n\n/**\n * Calculate the min amount received from amount and slippage\n *\n * @param amount: The amount to apply slippage\n * @param slippage: The slippage to apply in bps. 10 is 0.1%\n * @returns bigint\n */\nconst calculateMinAmount = (amount: bigint, slippage: number): bigint =>\n  amount - (amount * BigInt(slippage)) / BigInt(10000);\n\nexport {\n  buildApproveTx,\n  buildGetNonce,\n  calculateMinAmount,\n  checkContractAddress,\n  executeSwap,\n  fetchBuildExecuteTransaction,\n  fetchExecuteSwapTransaction,\n  fetchPrices,\n  fetchQuotes,\n  fetchSources,\n  fetchTokens,\n  hashQuote,\n  signQuote,\n};\n"],"mappings":"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","names":["mask","BN_0","BN_1","constants","SourceType","constants"]}